import { ApiError } from "../utils/ApiError";
import { ApiResponse } from "../utils/ApiResponse";
import HistoryController from "../models/History.model";
import { History } from "../types/History.model.type";
import { Request, response, Response } from "express";
import { UploadFile } from "../utils/Cloudinary";
import dotenv from "dotenv";
import { GoogleGenAI } from "@google/genai";
import axios from "axios";
import fs from "fs";
import { ModifiedPrompt } from "../secret";
dotenv.config();

interface UploadRequest extends Request {
  files: {
    UserImage: Express.Multer.File[];
  };
}

async function imageUrlToBase64(url: string) {
  const response = await axios.get(url, { responseType: "arraybuffer" });
  const mimeType = response.headers["content-type"];
  const base64 = Buffer.from(response.data).toString("base64");

  return { mimeType, data: base64 };
}

export const CreateNewImage = async (
  req: Request,
  res: Response<ApiResponse<History>>
) => {
  try {
    const ai = new GoogleGenAI({
      apiKey: process.env.GOOGLE_API_KEY || "",
    });
    const user = req?.user;
    if (!user) {
      throw new ApiError(401, "Not Authorized", "Not Authorized");
    }
    const sessionId = req.body?.sessionId;
    const prompt = req.body?.prompt;
    console.log("Received prompt:", prompt, sessionId);
    if (!sessionId || !prompt) {
      throw new ApiError(
        400,
        "Session Id and Prompt are required",
        "Session Id and Prompt are required"
      );
    }
    const UserImage = req.files
      ? (req.files as { [fieldname: string]: Express.Multer.File[] })[
          "UserImage"
        ]
      : [];
    console.log("Received files:", UserImage);
    if (!UserImage || UserImage.length === 0) {
      throw new ApiError(
        400,
        "User Image is required",
        "User Image is required"
      );
    }

    const uploadResults = await Promise.all(
      UserImage.map((file) => UploadFile(file.path))
    );
    console.log("Upload results:", uploadResults[0]);
    const imageUrl = uploadResults.map((r) => r.secure_url);
    const ImagePublicId = uploadResults.map((r) => r.public_id);

    if (imageUrl.length == 0) {
      throw new ApiError(
        500,
        "Error in uploading images",
        "Error in uploading images"
      );
    }

    const base64Images = await Promise.all(
      imageUrl.map((url) => imageUrlToBase64(url))
    );

    if (!base64Images) {
      throw new ApiError(
        500,
        "Error in processing images",
        "Error in processing images"
      );
    }
    const modifiedPrompt: string = ModifiedPrompt(prompt);
    const PromptForAi = [
      {
        text: modifiedPrompt,
      },
      ...base64Images.map((img) => ({ inlineData: img })),
    ];

    const AiImageResponse = await ai.models.generateContent({
      model: "gemini-2.5-flash",
      contents: PromptForAi,
    });
console.log('AI Image Response:', AiImageResponse);
let index = 1;
const AiGeneratedUploadedImagesUrl: string[] = [];
const AiGeneratedUploadedImagesPublicId: string[] = [];

if (!AiImageResponse?.candidates?.length) {
  throw new ApiError(
    500,
    "error in image creation",
    "error in image creation"
  );
}
console.log("AI Image Response:", AiImageResponse!.candidates[0]?.content?.parts);
console.log("AI Image Response:", AiImageResponse!.candidates[0]?.content);

    for (const part of AiImageResponse?.candidates[0]?.content?.parts || []) {
      if (!part?.inlineData?.data) {
        console.warn("No image data found in this part. Skipping...");
        continue;
      }
      if (part.inlineData) {
        const outputBuffer = Buffer.from(part.inlineData.data, "base64");
        const filePath = `generated/output_${Date.now()}_${index}.png`;
        fs.writeFileSync(filePath, outputBuffer);
        const uploaded = await UploadFile(filePath);

        AiGeneratedUploadedImagesUrl.push(uploaded.secure_url);
        AiGeneratedUploadedImagesPublicId.push(uploaded.public_id);

        fs.unlinkSync(filePath);

        index++;
      }
    }

    if (
      AiGeneratedUploadedImagesUrl.length === 0 ||
      AiGeneratedUploadedImagesPublicId.length === 0
    ) {
      throw new ApiError(
        500,
        "No images were generated by the AI",
        "No images were generated by the AI"
      );
    }

    const NewImageRecord = await HistoryController.create({
      userId: user._id,
      sessionId,
      imageUrl,
      GeneratedImageUrl: AiGeneratedUploadedImagesUrl,
      prompt,
      ImagePublicId,
      AiImagePublicId: AiGeneratedUploadedImagesPublicId,
    });

    return res.json({
      success: true,
      message: "Image generated successfully",
      data: [NewImageRecord],
      statusCode: 200,
    });
  } catch (error) {
    console.log("Error in CreateNewImage:", error);
    throw new ApiError(500, "Internal Server Error", error);
  }
};

export const EditExistingImage = async (
  req: Request,
  res: Response<ApiResponse<History>>
) => {
  try {
    const ai = new GoogleGenAI({
      apiKey: process.env.GOOGLE_API_KEY || "",
    });
    const user = req?.user;
    if (!user) {
      throw new ApiError(401, "Not Authorized");
    }
    const { sessionId, prompt, _id } = req.body;
    if (!sessionId || !prompt) {
      throw new ApiError(400, "Session Id and Prompt are required");
    }

    const existingRecord = await HistoryController.findById(_id);
    if (!existingRecord) {
      throw new ApiError(404, "History record not found");
    }
    const UserImage: string[] = existingRecord.GeneratedImageUrl!;
    if (!UserImage || UserImage.length === 0) {
      throw new ApiError(400, "User Image is required");
    }

    const base64Images = await Promise.all(
      UserImage.map((url) => imageUrlToBase64(url))
    );

    if (!base64Images) {
      throw new ApiError(500, "Error in processing images");
    }

    const PromptForAi = [
      {
        text: `Update the provided image based on the following change: add a red jacket. 
Keep the original subject, style, lighting, background, and proportions the same, but apply the requested modification naturally and realistically.`,
      },
      ...base64Images.map((img) => ({ inlineData: img })),
    ];

    const AiImageResponse = await ai.models.generateContent({
      model: "gemini-2.5-flash-image",
      contents: PromptForAi,
    });

    let index = 1;
    const AiGeneratedUploadedImagesUrl: string[] = [];
    const AiGeneratedUploadedImagesPublicId: string[] = [];

    if (!AiImageResponse?.candidates?.length) {
      throw new ApiError(500, "error in image creation");
    }

    for (const part of AiImageResponse?.candidates[0]?.content?.parts || []) {
      if (!part?.inlineData?.data) {
        console.warn("No image data found in this part. Skipping...");
        continue;
      }
      if (part.inlineData) {
        const outputBuffer = Buffer.from(part.inlineData.data, "base64");
        const filePath = `generated/output_${Date.now()}_${index}.png`;
        fs.writeFileSync(filePath, outputBuffer);
        const uploaded = await UploadFile(filePath);

        AiGeneratedUploadedImagesUrl.push(uploaded.secure_url);
        AiGeneratedUploadedImagesPublicId.push(uploaded.public_id);

        fs.unlinkSync(filePath);

        index++;
      }
    }

    if (
      AiGeneratedUploadedImagesUrl.length === 0 ||
      AiGeneratedUploadedImagesPublicId.length === 0
    ) {
      throw new ApiError(500, "No images were generated by the AI");
    }

    const NewImageRecord = await HistoryController.create({
      userId: user._id,
      sessionId,
      imageUrl: existingRecord.imageUrl,
      GeneratedImageUrl: AiGeneratedUploadedImagesUrl,
      prompt,
      ImagePublicId: existingRecord.ImagePublicId,
      AiImagePublicId: AiGeneratedUploadedImagesPublicId,
    });

    return res.json({
      success: true,
      message: "Image generated successfully",
      data: [NewImageRecord],
      statusCode: 200,
    });
  } catch (error) {
    console.log("Error in CreateNewImage:", error);
    if (error instanceof ApiError) {
      return res.status(error.statusCode).json({
        success: false,
        message: error.message,
        data: [],
        statusCode: error.statusCode,
      });
    }
  }
};
