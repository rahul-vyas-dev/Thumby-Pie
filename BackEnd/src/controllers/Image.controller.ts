import { ApiError } from "../utils/ApiError";
import { ApiResponse } from "../utils/ApiResponse";
import HistoryController from "../models/History.model";
import { History } from "../types/History.model.type";
import { Request, Response } from "express";
import { uploadBufferToCloudinary, UploadFile } from "../utils/Cloudinary";
import dotenv from "dotenv";
import { ModifiedPrompt, ModifiedPromptForEditImage } from "../secret";
import fetchImageBuffer from "../utils/fetchBufferImage";
import { AiGeneratedImageTaskId, fetchGeneratedImagesUrlMethod, } from "../utils/GenerateNewAiImage";
dotenv.config();

interface aiGenRes {
  data: {
    code: number;
    msg: string;
    data: {
      taskId: string;
    };
  };
}
interface aiGenImageRes {
  data: {
    code: number;
    msg: string;
    data: {
      taskId: string;
      paramJson: string;
      completeTime: string;
      response: {
        originImageUrl: null;
        resultImageUrl: string;
      };
      successFlag: boolean;
      errorCode: null;
      errorMessage: null;
      operationType: string;
      createTime: string;
    };
  };
}

export const CreateNewImage = async (
  req: Request,
  res: Response<ApiResponse<History>>
) => {
  try {
   
    const user = req?.user;
    if (!user) {
      throw new ApiError(401, "Not Authorized", "Not Authorized");
    }
    const sessionId = req.body?.sessionId;
    const image_size = req.body?.image_size;
    const prompt = req.body?.prompt;
    console.log("Received prompt:", prompt, sessionId);

    if (!sessionId || !prompt) {
      throw new ApiError(
        400,
        "Session Id and Prompt are required",
        "Session Id and Prompt are required"
      );
    }
    const UserImage = req.files
      ? (req.files as { [fieldname: string]: Express.Multer.File[] })[
          "UserImage"
        ]
      : [];
    console.log("Received files:", UserImage);
    if (!UserImage || UserImage.length === 0) {
      throw new ApiError(
        400,
        "User Image is required",
        "User Image is required"
      );
    }

    const uploadResults = await Promise.all(
      UserImage.map((file) => UploadFile(file.path))
    );
    console.log("Upload results:", uploadResults[0]);

    const imageUrl = uploadResults.map((r) => r.secure_url);
    const ImagePublicId = uploadResults.map((r) => r.public_id);

    if (imageUrl.length == 0) {
      throw new ApiError(
        500,
        "Error in uploading images",
        "Error in uploading images"
      );
    }

    const modifiedPrompt: string = ModifiedPrompt(prompt);
  
    const AiGeneratedUploadedImagesUrl: string[] = [];
    const AiGeneratedUploadedImagesPublicId: string[] = [];

    const taskId: aiGenRes = await AiGeneratedImageTaskId({
      modifiedPrompt,
      UserImage: imageUrl,
      image_size,
    });
    console.log("AI Generation Task ID:", taskId);

    if (taskId.data.code !== 200) {
      throw new ApiError(
        500,
        "Error in AI image generation",
        "Error in AI image generation"
      );
    }

    const taskIdValue = taskId.data.data.taskId;
    const fetchGeneratedImagesUrl: aiGenImageRes = await fetchGeneratedImagesUrlMethod(taskIdValue);

    console.log("Fetched Generated Images:", fetchGeneratedImagesUrl.data);
    console.log("Fetched Generated Images:", fetchGeneratedImagesUrl);

    if (fetchGeneratedImagesUrl.data.code !== 200) {
      throw new ApiError(
        500,
        "Error in fetching generated images",
        "Error in fetching generated images"
      );
    }

    const generatedImagesBuffer = await fetchImageBuffer(
      fetchGeneratedImagesUrl.data.data.response.resultImageUrl
    );
    const uploaded = await uploadBufferToCloudinary(generatedImagesBuffer);

    console.log("Uploaded Generated Image to Cloudinary:", uploaded);

    AiGeneratedUploadedImagesUrl.push(uploaded.secure_url);
    AiGeneratedUploadedImagesPublicId.push(uploaded.public_id);

    if (
      AiGeneratedUploadedImagesUrl.length === 0 ||
      AiGeneratedUploadedImagesPublicId.length === 0
    ) {
      throw new ApiError(
        500,
        "No images were generated by the AI",
        "No images were generated by the AI"
      );
    }

    const NewImageRecord = await HistoryController.create({
      userId: user._id,
      sessionId,
      imageUrl,
      GeneratedImageUrl: AiGeneratedUploadedImagesUrl,
      prompt,
      ImagePublicId,
      AiImagePublicId: AiGeneratedUploadedImagesPublicId,
    });

    return res.json({
      success: true,
      message: "Image generated successfully",
      data: [NewImageRecord],
      statusCode: 200,
    });
  } catch (error) {
    console.log("Error in CreateNewImage:", error);
    throw new ApiError(500, "Internal Server Error", error);
  }
};

export const EditExistingImage = async (
  req: Request,
  res: Response<ApiResponse<History>>
) => {
  try {
    const user = req?.user;
    if (!user) {
      throw new ApiError(401, "Not Authorized");
    }
    const sessionId = req.body?.sessionId;
    const prompt = req.body?.prompt;
    const _id = req.body?._id;
    const image_size = req.body?.image_size;
    if (!sessionId || !prompt||!_id) {
      throw new ApiError(400, "Session Id, Prompt, and ID are required");
    }

    const existingRecord = await HistoryController.findById(_id);
    if (!existingRecord) {
      throw new ApiError(404, "History record not found");
    }
    const UserImage: string[] = existingRecord.GeneratedImageUrl!;
    if (!UserImage || UserImage.length === 0) {
      throw new ApiError(400, "User Image is required");
    }

    const AiGeneratedUploadedImagesUrl: string[] = [];
    const AiGeneratedUploadedImagesPublicId: string[] = [];

    const modifiedPrompt: string = ModifiedPromptForEditImage(prompt);

    const taskId: aiGenRes = await AiGeneratedImageTaskId({
      modifiedPrompt,
      UserImage,
      image_size,
    });
    console.log("AI Generation Task ID:", taskId);

    if (taskId.data.code !== 200) {
      throw new ApiError(
        500,
        "Error in AI image generation",
        "Error in AI image generation"
      );
    }
    const taskIdValue = taskId.data.data.taskId;
    const fetchGeneratedImagesUrl: aiGenImageRes =
      await fetchGeneratedImagesUrlMethod(taskIdValue);

    console.log("Fetched Generated Images:", fetchGeneratedImagesUrl.data);
    // console.log("Fetched Generated Images:", fetchGeneratedImagesUrl);

    if (fetchGeneratedImagesUrl.data.code !== 200) {
      throw new ApiError(
        500,
        "Error in fetching generated images",
        "Error in fetching generated images"
      );
    }
    if (!fetchGeneratedImagesUrl.data.data.response) {
      throw new ApiError(
        500,
        "No response data found for generated images",
        "No response data found for generated images"
      );
    }
    const generatedImagesBuffer = await fetchImageBuffer(
      fetchGeneratedImagesUrl.data.data.response?.resultImageUrl
    );

    const uploaded = await uploadBufferToCloudinary(generatedImagesBuffer);

    console.log("Uploaded Generated Image to Cloudinary:", uploaded);

    AiGeneratedUploadedImagesUrl.push(uploaded.secure_url);
    AiGeneratedUploadedImagesPublicId.push(uploaded.public_id);

    if (
      AiGeneratedUploadedImagesUrl.length === 0 ||
      AiGeneratedUploadedImagesPublicId.length === 0
    ) {
      throw new ApiError(500, "No images were generated by the AI");
    }

    const NewImageRecord = await HistoryController.create({
      userId: user._id,
      sessionId,
      imageUrl: existingRecord.imageUrl,
      GeneratedImageUrl: AiGeneratedUploadedImagesUrl,
      prompt,
      ImagePublicId: existingRecord.ImagePublicId,
      AiImagePublicId: AiGeneratedUploadedImagesPublicId,
    });

    return res.json({
      success: true,
      message: "Image generated successfully",
      data: [NewImageRecord],
      statusCode: 200,
    });
  } catch (error) {
    console.log("Error in CreateNewImage:", error);
    if (error instanceof ApiError) {
      return res.status(error.statusCode).json({
        success: false,
        message: error.message,
        data: [],
        statusCode: error.statusCode,
      });
    }
  }
};
